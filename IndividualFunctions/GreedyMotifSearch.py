# Copyright Alexander Wood 2016.
# Solutions for Coursera's Bioinformatics 1 Course.




import itertools
import sys
import numpy



# Store as global variable since its values must be constant.
keys = 'ACGT'

# INPUT: Motif matrix
# OUTPUT: Count matrix
def Count(Motif):
    Count_mat = []

    # Initialize Count as a 4 x k matrix filled with zeros
    for i in range(len(keys)):
        temp_row = []
        for j in range(len(Motif[0])):
            temp_row.append(0)
        Count_mat.append(temp_row)
    
    # If the argument given is the file path name, call Motif() and
    # generate its Motif matrix.
    if type(Motif) == str:
        Motif = Motifs(Motif)

    for j in range(len(Motif[0])):         # Vary over columns...
        for i in range(len(Motif)):        # Vary over rows...
            for k in range(len(keys)):     # Vary over nucleotides...
                if Motif[i][j] == keys[k]: 
                    Count_mat[k][j] += 1

    return Count_mat





# INPUT: Profile matrix
# OUTPUT: Consensus vector where Consensus[j] yields the most common letter in column j.
def Consensus(Profile):
    Consensus = []
    
    for j in range(len(Profile[0])): #Column
        temp = []
        for i in range(len(Profile)): #Rows
            temp.append(Profile[i][j])

        letter_max = max(set(temp), key=temp.count)
        index_max = keys.index(letter_max)

        Consensus.append(keys[index_max])

    return Consensus






# INPUT: Count matrix
# OUTPUT: Profile matrix
def Profile(Count_mat):
    N = list(numpy.sum(Count_mat, 0))
    N = N[0]

    for i in range(len(Count_mat)):
        for j in range(len(Count_mat[i])):
            Count_mat[i][j] /= N

    Profile_mat = Count_mat
    return Profile_mat





##  INPUT: A profile matrix Profile, a DNA pattern Pattern
##  OUTPUT: The probability that Profile generates Pattern.

def ProbabilityGivenProfile(Profile, Pattern):
    Probability = 1 # Initialize to 1

    #print('pattern:', Pattern)
    for j in range(len(Pattern)):
        i = keys.index(Pattern[j])
        Probability *= Profile[i][j]

    return Probability



##  Profile-most k-mer problem.
##  INPUT: String Text, int k, 4xk matrix Profile
##  OUTPUT: the k-mer that was most likely to have been generated by Profile among all k-mers in Text
def ProfileMost_kmer(Text, Profile, k):   
    for i in range(len(Text) - k + 1):
        Pattern = Text[i:i+k]
        Probability = ProbabilityGivenProfile(Profile, Pattern)

        if i == 0:
            PMK = Pattern
            ProbPMK = Probability

        elif Probability > ProbPMK:
            PMK = Pattern
            ProbPMK = Probability

    return PMK

# INPUT: Motifs
##  OUTPUT: Score(motifs), the total number of mismatches.
def Score(Motifs):
    Consen = Consensus(Motifs)
    Score = 0

    for j in range(len(Motifs[0])): # Column
        for i in range(len(Motifs)): # Rows
            if Motifs[i][j] != Consen[j]:
                Score += 1

    return Score
    

##  INPUT: Integers k, t and list of strings DNA
##  OUTPUT: Collection of strings BestMotifs.
##  This algorithm runs WITHOUT pseudocounts, vastly damaging its reliability.
##  We improve on this algorithm after.
def GreedyMotifSearch_noPC(DNA, k, t):
    BestMotifs = [] # BestMotifs will be a motif matrix constructed from the first kmer in each string in DNA

    for dna in DNA:
        BestMotifs.append(dna[:k])

    FirstString = DNA[0]
    
    for i in range(len(FirstString) - k + 1):
        Motif = []
        Motif.append(FirstString[i:i+k])   # So, for each k-mer in DNA[0]...
        ProfMatrix = Profile(Count(Motif)) # ...Build profile from this k-mer

        for l in range(1, t):
            NextMotif = ProfileMost_kmer(DNA[l], ProfMatrix, k)
            Motif.append(NextMotif)
            ProfMatrix = Profile(Count(Motif))

        if Score(Motif) < Score(BestMotifs):
            BestMotifs = Motif

    return BestMotifs

