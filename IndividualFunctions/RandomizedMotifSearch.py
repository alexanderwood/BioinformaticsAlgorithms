# Copyright Alexander Wood 2016.
# Solutions for Coursera's Bioinformatics 1 Course.





import random
import sys
import numpy


# Store as global variable since its values must be constant.
keys = 'ACGT'




##  INPUT: A profile matrix Profile, a DNA pattern Pattern
##  OUTPUT: The probability that Profile generates Pattern.

def ProbabilityGivenProfile(Profile, Pattern):
    Probability = 1 # Initialize to 1

    for letter_index in range(len(Pattern)):
        letter = Pattern[letter_index]
        if letter != 'A' and letter != 'G' and letter != 'C' and letter != 'T':
            print('letter:', letter)
        i = keys.index(letter)
        Probability *= Profile[i][letter_index]

    return Probability


##  Profile-most k-mer problem.
##  INPUT: String Text, int k, 4xk matrix Profile
##  OUTPUT: the k-mer that was most likely to have been generated by Profile among all k-mers in Text
def ProfileMost_kmer(Text, Profile, k):   
    for i in range(len(Text) - k + 1):
        Pattern = Text[i:i+k]
        Probability = ProbabilityGivenProfile(Profile, Pattern)

        if i == 0:
            PMK = Pattern
            ProbPMK = Probability

        elif Probability >= ProbPMK:
            PMK = Pattern
            ProbPMK = Probability

    return PMK


# INPUT: Motif matrix
# OUTPUT: Count matrix
def Count(Motif):
    Count = []

    # Initialize Count as a 4 x k matrix filled with zeros
    for i in range(len(keys)):
        temp_row = []
        for j in range(len(Motif[0])):
            temp_row.append(0)
        Count.append(temp_row)

    for j in range(len(Motif[0])):         # Vary over columns...
        for i in range(len(Motif)):        # Vary over rows...
            for k in range(len(keys)):     # Vary over nucleotides...
                if Motif[i][j] == keys[k]: 
                    Count[k][j] += 1

    return Count   




# INPUT: Count matrix
# OUTPUT: Profile matrix
def Profile(Count):
    N = list(numpy.sum(Count, 0))
    N = N[0]

    for i in range(len(Count)):
        for j in range(len(Count[i])):
            Count[i][j] /= N

    Profile = Count
    return Profile


# INPUT: Profile matrix
# OUTPUT: Consensus vector where Consensus[j] yields the most common letter in column j.
def Consensus(Profile):
    Consensus = []
    
    for j in range(len(Profile[0])): #Column
        temp = []
        for i in range(len(Profile)): #Rows
            temp.append(Profile[i][j])

        letter_max = max(set(temp), key=temp.count)
        index_max = keys.index(letter_max)

        Consensus.append(keys[index_max])

    return Consensus





# INPUT: Motifs
##  OUTPUT: Score(motifs), the total number of mismatches.
def Score(Motifs):
    Consen = Consensus(Motifs)
    Score = 0

    for j in range(len(Motifs[0])): # Column
        for i in range(len(Motifs)): # Rows
            if Motifs[i][j] != Consen[j]:
                Score += 1

    return Score

##  INPUT: Collection of strings DNA, int k, int t
##  OUTPUT: Collection of strings BestMotifs, with pseudocounts,
##  Resulting from applying RandomizedMotifSearch 1000 times.
def RandomizedMotifSearch(DNA, k, t):
    Motifs = [] # Initialize random motifs

    # Randomly select a k-mer from each string & store it as Motifs.
    for dna in DNA:
        r = random.randint(0, len(DNA[0]) - k)
        Motifs.append(dna[r:r+k])

    BestMotifs = Motifs # Initialize the BestMotifs to the random Motifs.

    while True:
        # Apply Laplace's Rule of Succession to form Profile.
        CountMatrix = Count(Motifs)
        
        
        for row in range(len(CountMatrix)):
            for col in range(len(CountMatrix[0])):
                CountMatrix[row][col] += 1
                
        Prof_Matrix = Profile(CountMatrix)

        # Now, construct the Motifs matrix to be the collection of
        # profile-most probable k-mers under Prof_Matrix
        Motifs = []
        for dna in DNA:
            PMK = ProfileMost_kmer(dna, Prof_Matrix, k)
            Motifs.append(PMK)

        if Score(Motifs) < Score(BestMotifs):
            BestMotifs = Motifs
        else:
            return BestMotifs


def RandomizedMotifSearch_CallAndRepeat(DNA, k, t, N):
    most_common_matrix = []
    score = sys.maxsize
    ent = sys.maxsize
        
    for n in range(N):
        answers = RandomizedMotifSearch(DNA, k, t)

        score_temp = Score(answers)

        if score_temp < score:
            score = score_temp
            final_score = answers
            
    return final_score


